---
title: "Analyzing Gaming Addiction Trends and Player Engagement"
#subtitle: "Spring 2025"
author: "Bijay Adhikari"
bibliography: references.bib
nocite: |
  @*
number-sections: false
format:
  html:
    theme: default
    rendering: embed-resources
    code-fold: true
    code-tools: true
    toc: true
jupyter: python3
---


![Source: iStockPhoto](https://media.istockphoto.com/id/1132282499/photo/woman-playing-video-games.jpg?s=612x612&w=0&k=20&c=ljeQB2UiYW6fYNjAZONaCcdH1r7GPPE7SvXzQ5YJPMk=){fig-alt="A picture of a person indulged in video game."}


Have you ever found yourself so immersed in a video game that hours passed without you even noticing? I’m sure many of us have. For me, it started with the game, Grand Theft Auto: Vice City. After school, I would sit down to play and quickly become absorbed in its open virtual world, filled with action, rich stories, and endless possibilities. It was my version of freedom. I could cruise through cities, outrun the police, complete missions, and later laugh about it with friends. Video games provided a fun, simple, and great way to relax. 

Today, the gaming industry has transformed tremendously. Video games are more immersive, cinematic, and competitive than ever. Streamers and esports players are treated like celebrities, with huge fan bases following their every move. Video games have evolved as more than just a form of entertainment. They have become a way to express yourself, get inspired, and even explore future career options. However, with this rise comes a darker flip side, which is gaming addiction. As fun and exciting as games can be, excessive play can negatively impact mental health, productivity, and real-world relationships. Studies show that around 3-4% of gamers exhibit symptoms of gaming disorder, leading to anxiety, social withdrawal, and even depression in some cases [@pontes2021]. 

This blog aims to take a closer look at where we stand today when it comes to gaming addiction. By using real-time data from the Steam library, one of the world’s largest gaming platforms, this project explores how frequently people play, what types of games they spend the most time on, and what patterns might point to addictive behavior.



```{python}
## importing libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm

import scipy.stats as stats
import time
import itertools

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.metrics import classification_report

import warnings
warnings.filterwarnings('ignore')


games_data = pd.read_csv("../data/steam_game_data.csv")
users_data = pd.read_csv("../data/user_playtime_data.csv")
reviews_data = pd.read_csv("../data/reviews.csv")

```

## Data Sources

For this project, I chose Steam as the source of data due to its large user base, extensive game catalog, and publicly accessible API. Two main datasets were extracted using the Steam Web API specifically using the **ISteamApps/GetAppList** and **IPlayerService/GetOwnedGames** endpoints:  

- **`steam_game_data.csv`** : This dataset contains detailed information about 91,690 games, including metadata such as the game title, developer, publisher, genre, release date, supported platforms, multiplayer support, graphics quality, story depth, and metrics like review scores and player engagement statistics.  

- **`user_playtime_data.csv`** : This dataset consists of 66,187 player-specific data, capturing metrics like total playtime, recent playtime, and game ownership information. Each user (`user_id`) can have multiple games (`game_id`) associated with their account.  

Below you can find the Python script written to download the data. For the player data, the script generates a number of random Steam user IDs. For each valid public profile matching the user ID, the script retrieves information such as the number of games owned and the total and recent playtime.


```{python}
#| eval: false

# usercollections.py

import requests
import pandas as pd
import time
import random
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry

# Generate random Steam User IDs (these are not guaranteed to be valid)
def generate_random_steam_ids(n=50000):
    # SteamID64 range (valid SteamID64 values generally start from 76561197960265728)
    base_id = 76561197960265728
    return [str(base_id + random.randint(0, 1000000000)) for _ in range(n)]

# columns for the output CSV
columns = ['user_id', 'game_count', 'appid', 'name', 'playtime_forever', 'playtime_2weeks']

# Generate 50,000 random Steam User IDs
user_ids = generate_random_steam_ids()


session = requests.Session()
retry = Retry(connect=5, backoff_factor=1, status_forcelist=[502, 503, 504])
adapter = HTTPAdapter(max_retries=retry)
session.mount('http://', adapter)


API_KEY = 'API_KEY' # removing this for privacy

# Store user game data
all_user_data = []

# Fetch data for each random user
for idx, user_id in enumerate(user_ids):
    try:
        url = f'https://api.steampowered.com/IPlayerService/GetOwnedGames/v1/?key={API_KEY}&steamid={user_id}&include_appinfo=true&include_played_free_games=true'
        response = session.get(url, timeout=10)
        response.raise_for_status()
        data = response.json()
        
        if 'response' in data and 'games' in data['response']:
            games = data['response']['games']
            game_count = data['response'].get('game_count', 0)
            for game in games:
                game_data = {
                    'user_id': user_id,
                    'game_count': game_count,
                    'appid': game.get('appid'),
                    'name': game.get('name', 'Unknown'),
                    'playtime_forever': game.get('playtime_forever', 0),
                    'playtime_2weeks': game.get('playtime_2weeks', 0)
                }
                all_user_data.append(game_data)
        
        print(f'Fetched data for User ID {user_id} ({idx + 1}/{len(user_ids)})')
        
    except requests.exceptions.RequestException as e:
        print(f'Error fetching data for User ID {user_id}: {e}')

    # rate limiting
    time.sleep(0.5)


df = pd.DataFrame(all_user_data, columns=columns)

df.to_csv('user_playtime_data.csv', index=False)

print('Data collection complete. Saved to "user_playtime_data.csv"')

# --------------------------------------------------------------

# gamedatacollection.py


import requests
import pandas as pd
import time
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry

columns = [
    'game_id', 'title', 'developer', 'publisher', 'genre', 'release_date',
    'platforms', 'multiplayer_support', 'graphics_quality', 'story_depth',
    'DLC_count', 'max_concurrent_players', 'positive_review_pct',
    'average_review_score', 'review_sentiment_score', 'number_of_reviews'
]

app_list_url = 'http://api.steampowered.com/ISteamApps/GetAppList/v2/'
app_list_response = requests.get(app_list_url)
app_list_data = app_list_response.json()


apps = app_list_data['applist']['apps']
app_ids = [str(app['appid']) for app in apps][:100000]


# set up session
session = requests.Session()
retry = Retry(connect=5, backoff_factor=1, status_forcelist=[502, 503, 504])
adapter = HTTPAdapter(max_retries=retry)
session.mount('http://', adapter)

# store game data
all_games_data = []

for idx, app_id in enumerate(app_ids):
    try:
        url = f'http://store.steampowered.com/api/appdetails?appids={app_id}'
        response = session.get(url, timeout=10)
        response.raise_for_status()
        game_data = response.json()
        
        if game_data.get(app_id) and game_data[app_id]['success']:
            data = game_data[app_id]['data']
            
            filtered_data = {
                'game_id': data.get('steam_appid'),
                'title': data.get('name'),
                'developer': ', '.join(data.get('developers', [])) if data.get('developers') else 'Unknown',
                'publisher': ', '.join(data.get('publishers', [])) if data.get('publishers') else 'Unknown',
                'genre': ', '.join([genre['description'] for genre in data.get('genres', [])]) if data.get('genres') else 'N/A',
                'release_date': data.get('release_date', {}).get('date') if isinstance(data.get('release_date'), dict) else 'TBA',
                'platforms': ', '.join([k for k, v in data.get('platforms', {}).items() if v]) if data.get('platforms') else 'Unknown',
                'multiplayer_support': 'Multi-player' in [category['description'] for category in data.get('categories', [])] if data.get('categories') else False,
                'DLC_count': len(data.get('dlc', [])) if data.get('dlc') else 0,
                'max_concurrent_players': data.get('recommendations', {}).get('total', 0) if data.get('recommendations') else 0,
                'positive_review_pct': data.get('metacritic', {}).get('score', 0) if data.get('metacritic') else 0,
                'average_review_score': data.get('metacritic', {}).get('score', 0) if data.get('metacritic') else 0,
                'review_sentiment_score': data.get('metacritic', {}).get('score', 0) if data.get('metacritic') else 0,
                'number_of_reviews': data.get('recommendations', {}).get('total', 0) if data.get('recommendations') else 0,
                'graphics_quality': 'High' if '4K' in data.get('short_description', '') else 'Standard',
                'story_depth': 'Deep' if 'story' in data.get('short_description', '').lower() else 'Light'
            }

            # get Max Concurrent Players
            max_players_url = f'https://api.steampowered.com/ISteamUserStats/GetNumberOfCurrentPlayers/v1/?appid={app_id}'
            max_players_response = requests.get(max_players_url, timeout=10)

            if max_players_response.status_code == 200:
                max_players_data = max_players_response.json()
                filtered_data['max_concurrent_players'] = max_players_data.get('response', {}).get('player_count', 0)
            else:
                print(f"Failed to fetch max players for App ID {app_id}: Status Code {max_players_response.status_code}")
                filtered_data['max_concurrent_players'] = 0

            all_games_data.append(filtered_data)
        
        print(f"Fetched data for App ID {app_id} ({idx + 1}/{len(app_ids)})")

    except requests.exceptions.RequestException as e:
        print(f"Error fetching data for App ID {app_id}: {e}")
    
    time.sleep(0.5)
        


df = pd.DataFrame(all_games_data, columns=columns)


df.to_csv('games_data.csv', index=False)

print("Data collection complete. Saved to 'games_data.csv'")



```



## Data Preparation

The Steam library includes more than just released games. It also contains test builds, delisted titles, and placeholder entries. Many of these games/apps had non-standard release dates, such as “Q2 2025” or “Coming soon.” which were removed for the project.

To prepare the data for analysis, entries with missing data were removed.  Playtime values were converted into hours which originally were recorded in minutes.

Here are the columns in the final merged dataset:
```{python}

# Removing rows with any missing values
games_data.dropna(inplace=True)

# Attemptting to parse the dates with possible date formats : 
# Possible formats known from: https://steamcommunity.com/sharedfiles/filedetails/?id=2554483179#:~:text=Date%20part%20order%20can%20be,format%20will%20be%20applied%20immediately.

valid_dates_format1 = pd.to_datetime(games_data['release_date'], format='%d %b, %Y', errors='coerce')
valid_dates_format2 = pd.to_datetime(games_data['release_date'], format='%b %d, %Y', errors='coerce')
valid_dates_format3 = pd.to_datetime(games_data['release_date'], format='%d %b %Y', errors='coerce')

# Identify rows that do not match either of the formats
invalid_dates = games_data[(valid_dates_format1.isna()) & (valid_dates_format2.isna()) & (valid_dates_format3.isna())]

# let's remove those invalid dates
invalid_dates_list = invalid_dates['release_date'].tolist()
games_data = games_data[~games_data['release_date'].isin(invalid_dates_list)]


# Combining all parsed dates
games_data['release_date'] = valid_dates_format1.fillna(valid_dates_format2).fillna(valid_dates_format3)

# Convert dates to 'YYYY-MM-DD' format for consistency only
games_data['release_date'] = games_data['release_date'].dt.strftime('%Y-%m-%d')


# Rename the column from 'appid' to 'game_id'
users_data.rename(columns={'appid': 'game_id'}, inplace=True)

# let's add avg_playtime coloumn - for viz
users_data['avg_playtime'] = users_data['playtime_2weeks'] / 14

# Convert playtime from minutes to hours
users_data['playtime_2weeks'] = users_data['playtime_2weeks'] / 60
users_data['playtime_forever'] = users_data['playtime_forever'] / 60

merged_data = users_data.merge(games_data, on='game_id', how='left')
merged_data.dropna(inplace=True)
for i, col in enumerate(merged_data.columns, start=1):
    print(f"{i}. {col}")
```

# Analysis

###  How much time are people spending on gaming per week?

The chart below shows the number of hours active users spent gaming per week, based on Steam data. To be considered "active," users needed to have played at least a minute in the past two weeks.

```{python}
import plotly.express as px
import plotly.graph_objects as go

# Calculate weekly playtime
active_users = users_data[users_data['playtime_2weeks'] > 0].copy()
active_users['weekly_playtime_hours'] = active_users['playtime_2weeks'] / 2

# Create histogram
fig = px.histogram(
    active_users,
    x='weekly_playtime_hours',
    nbins=30,
    title='Distribution of Weekly Playtime Among Active Users',
    labels={'weekly_playtime_hours': 'Average Weekly Playtime (Hours)'}
)

# Add the threshold line
fig.add_vline(
    x=20,
    line_dash="dash",
    line_color="red",
    annotation_text="Addiction Threshold (20 hours)",
    annotation_position="top right"
)

fig.update_layout(
    xaxis_title='Average Weekly Playtime (Hours)',
    yaxis_title='Number of Active Users',
    bargap=0.1
)

fig.show()

```


The distribution is highly right-skewed, meaning that most users play only a few hours per week, while a smaller group spends a significantly larger amount of time gaming.

A red vertical line is the 20-hour threshold, used thorughout the analysis as the gaming addiction theshold. As the chart shows, the majority of users fall well below this line, clustered between 0-10 hours per week.

::: {.callout-note title="Why 20 Hours?"}

The **20-hour threshold** used in this analysis is based on findings from the *Journal of Behavioral Addictions* [@ajp2021gaming], which reported that addicted individuals played an average of approximately 20 hours per week.

:::




While the histogram gives us a general sense of how often people play, it doesn't tell us much about **how** many users might be at risk. To get a clearer picture, users were categorized based on their weekly playtime.

Let's break this down with a pie chart that groups active users into three categories:

- **Casual Gamers** (under 7 hours per week)  
- **Moderate Gamers** (7 to threshold hours per week)  
- **Potentially Addicted** (above the threshold)


Now, let’s take a look at how these groups compare visually:


```{python}
import plotly.graph_objects as go
import pandas as pd

# Define threshold values and labels
thresholds = list(range(20, 41, 5))
labels = ['Casual Gamer', 'Moderate Gamer', 'Potential Addiction']
colors = ['#46B2DE', '#AEE1AE', '#E57873'] 
frames = []
buttons = []

# Generate pie chart data for each threshold
for threshold in thresholds:
    def categorize(hours):
        if hours < 7:
            return 'Casual Gamer'
        elif hours < threshold:
            return 'Moderate Gamer'
        else:
            return 'Potential Addiction'

    df = active_users.copy()
    df['category'] = df['weekly_playtime_hours'].apply(categorize)
    counts = df['category'].value_counts()
    values = [counts.get(label, 0) for label in labels]

    frames.append(go.Pie(labels=labels, values=values, marker=dict(colors=colors)))

    buttons.append(dict(
        method="update",
        label=f"{threshold} hrs",
        args=[{"values": [values]}],
    ))

# Start with the first threshold's values
init_counts = active_users['weekly_playtime_hours'].apply(lambda h: 'Casual Gamer' if h < 7 else 'Moderate Gamer' if h < 20 else 'Potential Addiction').value_counts()
init_values = [init_counts.get(label, 0) for label in labels]

# Create figure
fig = go.Figure(
    data=[go.Pie(labels=labels, values=init_values, marker=dict(colors=colors))],
    layout=go.Layout(
        title_text="Playtime Category Distribution",
        title_x=0.5,
        height=600,
        margin=dict(t=80, b=100),
        updatemenus=[dict(
            type="dropdown",
            direction="down",
            x=0.01,             # for left position
            xanchor="left",  # anchor to left
            y=0,                # bottom
            yanchor="bottom",
            showactive=True,
            buttons=buttons
        )]
    )
)

fig.show()



```

::: {.callout-note title="Interactive Feature"}
Use the **dropdown menu below the chart** to adjust the *Addiction Threshold* between **20 and 40 hours** per week.  
:::


Based on the 20 hours per week threshold, the results show that a significant majority of users fall well below this level.

**About 75.4%** of active users fall under **Casual Gamers**, meaning they play less than 7 hours per week. This suggests that most people use gaming as a light, recreational activity; something they enjoy in short sessions without making it a major part of their routine.

**Moderate Gamers**, who play between 7 and 20 hours per week, make up **17.9%** of active users. This group shows healthy engagement, likely made up of people who play consistently but still manages to balance gaming with other parts of their lives.

Only **6.6%** of users fall into the **Potential Addiction** category, playing more than 20 hours per week. While this number is not insignificant, it does suggest that gaming addiction is not widespread in this dataset. The overall pattern shows that the majority of gamers engage in moderate or minimal play.

### What drives players to keep playing?
```{python}

merged_data = users_data.merge(games_data, on='game_id', how='left')
merged_data.dropna(inplace=True)

# filter only active users (played in last 2 weeks)
merged_data = merged_data[merged_data['playtime_2weeks'] > 0]

# convert 'multiplayer_support' to numeric for correlation
merged_data['multiplayer_support'] = merged_data['multiplayer_support'].astype(int)

# aply log transformation to reduce skewness
merged_data['playtime_forever'] = np.log1p(merged_data['playtime_forever'])
merged_data['playtime_2weeks'] = np.log1p(merged_data['playtime_2weeks'])
merged_data['DLC_count'] = np.log1p(merged_data['DLC_count'])
merged_data['max_concurrent_players'] = np.log1p(merged_data['max_concurrent_players'])
merged_data['average_review_score'] = np.log1p(merged_data['average_review_score'])

# select certain columns for correlation
design_elements = ["DLC_count", "multiplayer_support", "max_concurrent_players", "average_review_score"]
corr_matrix = merged_data[["playtime_forever"] + design_elements].corr().round(2)

# Interactive heatmap with Plotly
fig = px.imshow(
    corr_matrix,
    text_auto=True,
    color_continuous_scale="RdBu_r",
    title="Correlation Between Game Design Elements and Playtime",
    aspect="auto"
)

fig.update_layout(
    xaxis_title="Game Design Elements",
    yaxis_title="Playtime & Design Elements",
    coloraxis_colorbar=dict(title="Correlation"),
    title_x=0.5,
    margin=dict(t=80, l=60, r=60, b=60)
)

fig.show()

```

Observe the heatmap above that shows how different game design elements relate to long-term playtime. 

One of the strongest correlations shows up with **multiplayer support**. The games that let people play together, whether cooperatively or competitively, tend to create a more social and engaging experience. Titles like *Counter-Strike: Global Offensive*, *Dota 2*, or *Valorant* are popular multiplayer games. Not only can you can team up with friends but you can also go head-to-head with strangers. This social side of these games can turn a quick session into a regular habit.


**Maximum concurrent players** also shows a strong positive correlation. This probably has a lot to do with the size and popularity of certain games. Titles like *PUBG*, *Rust*, or *ARK: Survival Evolved* are built for large-scale multiplayer, where you enter into a world with lots of other players. The more people there are online, the more unpredictable and exciting each session becomes. No two matches feel the same, and that variety can really keep players coming back.


The number of **downloadable content packs (DLCs)** also appears to play a role. Games like *The Sims 4* or *Cities: Skylines* frequently release DLCs that expand gameplay, add new mechanics, or refresh the visual experience. Players likley find it fun to explore new contents that can be added over time which makes them stick aroung longer.

Interestingly, **average review scores** also correlate positively with playtime, but to a lesser degree. While good reviews may attract players initially, they don’t seem to keep players engaged in the same way that gameplay mechanics and social features do. 

###  Hypothesis Testing: Multiplayer Support and Gaming Addiction

Let's investigate whether there's a relationship between multiplayer support and the likelihood of gaming addiction.

- **Null Hypothesis (H₀):**  
    There is no association between multiplayer support and addiction status. In other words, the proportion of addicted players is the same regardless of whether a game has multiplayer support or not.

- **Alternative Hypothesis (H₁):**  
    There is an association between multiplayer support and addiction status. That is, the proportion of addicted players differs between games with and without multiplayer support.


::: {.callout-note title="Chi-Square Test Result"}
```{python}

#hyopthesis testing
import pandas as pd
from scipy.stats import chi2_contingency

merged_data = users_data.merge(games_data, on='game_id', how='left')
merged_data.dropna(inplace=True)

merged_data = merged_data[merged_data['playtime_2weeks'] > 0]
merged_data['multiplayer_support'] = merged_data['multiplayer_support'].astype(int)


df_filtered = merged_data[merged_data['playtime_2weeks'] > 0].copy()

# Create addicted column: 1 if playtime_2weeks > 20, else 0
df_filtered['addicted'] = (df_filtered['playtime_2weeks'] > 40).astype(int)

# Create contingency table between multiplayer_support and addicted status
contingency_table = pd.crosstab(df_filtered['multiplayer_support'], df_filtered['addicted'])

#print("Contingency Table:")
#print(contingency_table)

# Perform the chi-square test
chi2, p, dof, expected = chi2_contingency(contingency_table)
print(f"\nChi-square Statistic: {chi2:.4f}")
print(f"Degrees of Freedom: {dof}")
print(f"P-value: {p}")
```
:::

Since the p-value is extremely small (p < 0.05), we reject the null hypothesis. This indicates that there is a statistically significant association between multiplayer support and gaming addiction status. In summary, the data provide strong evidence that the proportion of players classified as addicted differs significantly between games with and without multiplayer support.


#### Let’s Go Further: T-Tests on Other Game Features

To explore this further, let's run t-tests to compare whether certain game features differ significantly between addicted and non-addicted players.

::: {.callout-note title="Chi-Square Test Result"}
```{python}

import pandas as pd
import numpy as np
from scipy.stats import chi2_contingency
from scipy.stats import ttest_ind


merged_data = users_data.merge(games_data, on='game_id', how='left')
merged_data.dropna(inplace=True)

merged_data = merged_data[merged_data['playtime_2weeks'] > 0]

merged_data['multiplayer_support'] = merged_data['multiplayer_support'].astype(int)


# Assume df_filtered is defined as before with an 'addicted' column
df_filtered = merged_data[merged_data['playtime_2weeks'] > 0].copy()
df_filtered['addicted'] = (df_filtered['playtime_2weeks'] > 40).astype(int)

# Define groups
group_addicted = df_filtered[df_filtered['addicted'] == 1]
group_non_addicted = df_filtered[df_filtered['addicted'] == 0]

# Function to run and print t-test results for a given predictor
def run_ttest(predictor,proper_name):
    t_stat, p_value = ttest_ind(group_addicted[predictor], group_non_addicted[predictor], nan_policy='omit')
    print(f"T-test for {proper_name}:")
    print(f"  t-statistic: {t_stat:.4f}")
    print(f"  p-value: {p_value:.4f}\n")

# Run t-tests for each predictor
run_ttest('DLC_count', 'DLC Count')
run_ttest('max_concurrent_players', 'Maxiumum Concurrent Players')
run_ttest('average_review_score', 'Average Review Score')

```
:::

The results show a clear difference in **DLC count** between the two groups. With a t-statistic of 3.99 and a p-value of 0.0001, it’s pretty clear that players who fall into the addicted category are more likely to play games that offer more downloadable content. 

We can see a similar pattern with **maximum concurrent players**. The t-statistic came out to 3.91 with the same p-value, which suggests that addicted players tend to be more drawn to games with large, active communities. 

On the flip side, **average review score** didn’t show any real difference between the groups. The t-statistic was -0.92, and the p-value was around 0.35, which tells us that reviews don’t really influence whether someone ends up playing a game excessively. A great review might convince someone to try a game, but it doesn’t necessarily mean they’ll keep coming back for dozens of hours.

Altogether, these results back up what we saw earlier in the correlation heatmap. Social features and new downloadable contents seem to play a much bigger role in keeping players in the game than just the game’s rating/review.



## What Genres Are Most Engaging?

To understand what types of games addicted and non-addicted users are spending time on, let's break down total playtime by game genre. The charts below compare the top five genres based on total playtime for each group.


```{python}

import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

# Merge and clean
merged = users_data.merge(games_data, on="game_id", how="inner")
merged = merged.dropna(subset=["genre", "playtime_2weeks"])

# Split groups
addicted = merged[merged["playtime_2weeks"] > 40].copy()
non_addicted = merged[(merged["playtime_2weeks"] > 0) & (merged["playtime_2weeks"] <= 40)].copy()

# Calculate top 5 genres for each group
def top_genres(df):
    return df.groupby("genre")["playtime_2weeks"].sum().sort_values(ascending=False).head(5).reset_index()

addicted_top = top_genres(addicted)
non_addicted_top = top_genres(non_addicted)

# Create consistent genre-color mapping
all_genres = pd.concat([addicted_top["genre"], non_addicted_top["genre"]]).unique()
colors = px.colors.qualitative.Pastel
genre_colors = {genre: colors[i % len(colors)] for i, genre in enumerate(sorted(all_genres))}

# Addicted plot
fig1 = px.bar(
    addicted_top,
    x="genre",
    y="playtime_2weeks",
    title="Top 5 Genres by Total Playtime (Addicted Users)",
    labels={"playtime_2weeks": "Total Playtime (Hours)", "genre": "Game Genre"},
    color="genre",
    color_discrete_map=genre_colors
)

fig1.update_layout(showlegend=False, xaxis_tickangle=-30)
fig1.show()


```


# 
For addicted users, Strategy games take the lead with the highest total playtime. This suggests that players who spend extended hours gaming may be especially drawn to games that involve planning, decision-making, and long sessions. Following Strategy include RPGs, Action, and hybrid genres like Action-Adventure-RPG, which combine exploration, combat, and story progression in one package.

These types of games often include deep mechanics and flexible systems which encourages prolonged engagement. They tend to be highly replayable by offering varied experiences across different playthroughs.


```{python}

# Non-addicted plot
fig2 = px.bar(
    non_addicted_top,
    x="genre",
    y="playtime_2weeks",
    title="Top 5 Genres by Total Playtime (Non-Addicted Users)",
    labels={"playtime_2weeks": "Total Playtime (Hours)", "genre": "Game Genre"},
    color="genre",
    color_discrete_map=genre_colors
)

fig2.update_layout(showlegend=False, xaxis_tickangle=-30)


fig2.show()
```

# 
Non-addicted players, on the other hand, spend most of their time on Action and Action-Adventure genres. These games tend to offer quick, exciting gameplay in small sessions for more casual play. Titles that fall into these genres often include straightforward objectives, and fast-paced mechanics with visually engaging environments.


While both groups enjoy genres that offer action and adventure, addicted users lean more heavily into genres that demand tactical planning and problem-solving, like Strategy and RPGs. Non-addicted users appear to prefer more fast-paced and accessible experiences. 


# Predicting Gaming Addiction

After exploring trends in playtime, game design, and genre preferences, the next  step is to see if we could predict gaming addiction using machine learning.

To do this, I trained and tested several classification models using both numerical features (like total number of games owned, average review score, and number of reviews) and categorical features (such as genre, platforms, and whether a game supports multiplayer). Together, these features offer a broad snapshot of both the player's behavior and the characteristics of the games they engage with.

The goal here is to build a model that can distinguish between users who are likely to be addicted and those who are not, based on the types of games they play and how they interact with them.

Below is a comparison of the top-performing models. 


::: {.callout-note}

Using the dropdown, you can check out the chart below to view how each model performed.

:::





```{python}
import plotly.graph_objects as go

# Define model names and metrics
models = ["Logistic Regression", "XGBoost", "KNN", "Bagging", "Decision Tree", "SVM"]

# Scores for "Not Addicted" and "Addicted"
scores = {
    "Logistic Regression": {
        "Not Addicted": [0.8101, 0.7467, 0.7771],
        "Addicted": [0.7647, 0.8246, 0.7935]
    },
    "XGBoost": {
        "Not Addicted": [0.8611, 0.7616, 0.8083],
        "Addicted": [0.7860, 0.8769, 0.8289]
    },
    "KNN": {
        "Not Addicted": [0.7559, 0.6574, 0.7032],
        "Addicted": [0.6964, 0.7873, 0.7391]
    },
    "Bagging": {
        "Not Addicted": [0.8236, 0.7654, 0.7934],
        "Addicted": [0.7805, 0.8358, 0.8072]
    },
    "Decision Tree": {
        "Not Addicted": [0.8704, 0.7002, 0.7761],
        "Addicted": [0.7488, 0.8955, 0.8156]
    },
    "SVM": {
        "Not Addicted": [0.8095, 0.7281, 0.7667],
        "Addicted": [0.7525, 0.8283, 0.7886] 
    }
}

# Initialize the first model (XGBoost) as default
initial_model = "XGBoost"
metrics = ["Precision", "Recall", "F1-Score"]
fig = go.Figure()

fig.add_trace(go.Bar(
    name="Not Addicted",
    x=metrics,
    y=scores[initial_model]["Not Addicted"],
    marker_color="#2a9d8f"
))
fig.add_trace(go.Bar(
    name="Addicted",
    x=metrics,
    y=scores[initial_model]["Addicted"],
    marker_color="#e76f51"
))

# Dropdown buttons
buttons = []
for model in models:
    buttons.append(dict(
        label=model,
        method="update",
        args=[{"y": [scores[model]["Not Addicted"], scores[model]["Addicted"]],
               "x": [metrics, metrics]},
              {"title": f"Classification Metrics for {model}"}]
    ))

# Layout
fig.update_layout(
    updatemenus=[dict(
        buttons=buttons,
        direction="down",
        showactive=True,
        x=0.99,
        xanchor="right",
        y=1.15,
        yanchor="top"
    )],
    barmode="group",
    title=f"Classification Metrics for {initial_model}",
    yaxis_title="Score",
    yaxis=dict(range=[0.6, 0.9]),
    height=500
)

fig.show(config={"displayModeBar": False})

```

#
Based on the comparison, XGBoost is the top-performing model, with the highest F1-score for the Addicted class (0.8289) and strong, balanced metrics across both classes. Models like Bagging and Decision Tree also performed well, with solid precision and recall, while Logistic Regression was a good starting point, but its recall was a bit lower. On the other hand, KNN and SVM struggled, especially in identifying "Not Addicted" users accurately. This suggests that more advanced ensemble-based models are better suited for capturing the patterns behind gaming addiction. 

Now that we know XGBoost performs best, let's take a closer look at which features had the most influence in its predictions:

```{python}
import pandas as pd
import plotly.express as px

# Top 10 features and importance scores
feature_data = pd.DataFrame({
    "Feature": [
        "game_count",
        "developer_Aurora Studio",
        "number_of_reviews",
        "genre_Casual",
        "genre_Action",
        "genre_Action, Adventure, Indie",
        "publisher_Slitherine Ltd.",
        "max_concurrent_players",
        "publisher_Valve",
        "publisher_Team17"
    ],
    "Importance": [
        0.028460,
        0.022018,
        0.021947,
        0.019471,
        0.019317,
        0.018006,
        0.016553,
        0.014739,
        0.014415,
        0.013994
    ]
})

# Create interactive horizontal bar chart
fig = px.bar(
    feature_data.sort_values("Importance"),
    x="Importance",
    y="Feature",
    orientation="h",
    title="Top 10 Most Important Features in XGBoost Model",
    labels={"Importance": "Feature Importance", "Feature": "Feature"},
    color="Importance"
)

fig.update_traces(marker_color="#3b82f6")

fig.update_layout(height=500, yaxis_title="", coloraxis_showscale=False)

# Hide Plotly mode bar
fig.show(config={"displayModeBar": False})


```



 Interestingly, the number of games owned came out as the most influential feature, which makes sense since players who own a large library may be more engaged overall. Specific developers and publishers also played a role, with games from Aurora Studio, Valve, and Team17 showing up frequently among addicted users. Certain genres stood out too: titles labeled as Casual, Action, or hybrid genres like Action-Adventure-Indie carried significant weight in the model. The number of user reviews and maximum concurrent players were also important, suggesting that both popularity and social engagement may contribute to prolonged playtime. Overall, these features paint a picture of gaming addiction as a mix of player behavior, game design, and community-driven influence.

