---
title: "Analyzing Gaming Addiction Trends and Player Engagement"
author: "Bijay Adhikari"
bibliography: references.bib
nocite: |
  @*
number-sections: false
format:
  html:
    theme: default
    rendering: embed-resources
    code-fold: true
    code-tools: true
    toc: true
jupyter: python3
---


![Screenshot from one of the most popular games, Grand Theft Auto V, capturing the iconic trio.](gta.jpg)


Have you ever found yourself so immersed in a video game that hours passed without you even noticing? I’m sure many of us have. For me, it started with the game, Grand Theft Auto: Vice City. After school, I would sit down to play and quickly become absorbed in its open virtual world, filled with action, rich stories, and endless possibilities. It was my version of freedom. I could cruise through cities, outrun the police, complete missions, and later laugh about it with friends. Video games provided a fun, simple, and great way to relax. 

Today, the gaming industry has transformed tremendously. Video games are more immersive, cinematic, and competitive than ever. Streamers and esports players are treated like celebrities, with huge fan bases following their every move. Video games have evolved as more than just a form of entertainment. They have become a way to express yourself, get inspired, and even explore future career options. However, with this rise comes a darker flip side, which is gaming addiction. As fun and exciting as games can be, excessive play can negatively impact mental health, productivity, and real-world relationships. Studies show that around 3-4% of gamers exhibit symptoms of gaming disorder, leading to anxiety, social withdrawal, and even depression in some cases [@pontes2021]. 

This blog aims to take a closer look at where we stand today when it comes to gaming addiction. By using real-time data from [Steam](https://store.steampowered.com/) <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Steam_icon_logo.svg/1920px-Steam_icon_logo.svg.png" alt="Steam Icon" width="20" height="20" />, one of the world’s largest gaming platforms, this project explores how frequently people play, what types of games they spend the most time on, and what patterns might point to addictive behavior.

::: {.callout-note icon=false}

## Research Questions

* How much time are people spending on gaming per week?
* What drives players to keep playing?
* Are multiplayer games more addictive?
* What genres are most engaging?
* How does the sentiment of user reviews differ between addicted and non-addicted players?
* Can we predict gaming addiction based on game features?

:::

```{python}
## importing libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm

import scipy.stats as stats
import time
import itertools

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.pipeline import Pipeline
from sklearn.compose import ColumnTransformer
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.metrics import classification_report

import warnings
warnings.filterwarnings('ignore')


games_data = pd.read_csv("../data/steam_game_data.csv")
users_data = pd.read_csv("../data/user_playtime_data.csv")
reviews_data = pd.read_csv("../data/reviews.csv")

```

## Data Sources

For this project, I chose [Steam](https://store.steampowered.com/) <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Steam_icon_logo.svg/1920px-Steam_icon_logo.svg.png" alt="Steam Icon" width="20" height="20" /> as the source of data due to its large user base, extensive game catalog, and publicly accessible API. 



 Getting the data required some patience. Steam’s API has request limits, so I had to write a script that moved slowly to find public profiles, checking their games, and logging playtime details over thousands of users randomly generated. Following are the two main datasets used for this project: 

- **`steam_game_data.csv`** : This dataset contains detailed information about 90,000 games, including metadata such as the game title, developer, publisher, genre, release date, supported platforms, multiplayer support, graphics quality, story depth, and metrics like review scores and player engagement statistics.  

- **`user_playtime_data.csv`** : This dataset consists of over 90,000 player-specific data, capturing metrics like total playtime, recent playtime, and game ownership information.


Below you can find the Python script written to download the data. For the player data, the script generates a number of random Steam user IDs. For each valid public profile matching the user ID, the script retrieves information such as the number of games owned and the total and recent playtime.


```{python}
#| eval: false

# usercollections.py

import requests
import pandas as pd
import time
import random
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry

# Generate random Steam User IDs (these are not guaranteed to be valid)
def generate_random_steam_ids(n=50000):
    # SteamID64 range (valid SteamID64 values generally start from 76561197960265728)
    base_id = 76561197960265728
    return [str(base_id + random.randint(0, 1000000000)) for _ in range(n)]

# columns for the output CSV
columns = ['user_id', 'game_count', 'appid', 'name', 'playtime_forever', 'playtime_2weeks']

# Generate 50,000 random Steam User IDs
user_ids = generate_random_steam_ids()


session = requests.Session()
retry = Retry(connect=5, backoff_factor=1, status_forcelist=[502, 503, 504])
adapter = HTTPAdapter(max_retries=retry)
session.mount('http://', adapter)


API_KEY = 'API_KEY' # removing this for privacy

# Store user game data
all_user_data = []

# Fetch data for each random user
for idx, user_id in enumerate(user_ids):
    try:
        url = f'https://api.steampowered.com/IPlayerService/GetOwnedGames/v1/?key={API_KEY}&steamid={user_id}&include_appinfo=true&include_played_free_games=true'
        response = session.get(url, timeout=10)
        response.raise_for_status()
        data = response.json()
        
        if 'response' in data and 'games' in data['response']:
            games = data['response']['games']
            game_count = data['response'].get('game_count', 0)
            for game in games:
                game_data = {
                    'user_id': user_id,
                    'game_count': game_count,
                    'appid': game.get('appid'),
                    'name': game.get('name', 'Unknown'),
                    'playtime_forever': game.get('playtime_forever', 0),
                    'playtime_2weeks': game.get('playtime_2weeks', 0)
                }
                all_user_data.append(game_data)
        
        print(f'Fetched data for User ID {user_id} ({idx + 1}/{len(user_ids)})')
        
    except requests.exceptions.RequestException as e:
        print(f'Error fetching data for User ID {user_id}: {e}')

    # rate limiting
    time.sleep(0.5)


df = pd.DataFrame(all_user_data, columns=columns)

df.to_csv('user_playtime_data.csv', index=False)

print('Data collection complete. Saved to "user_playtime_data.csv"')

# --------------------------------------------------------------

# gamedatacollection.py


import requests
import pandas as pd
import time
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry

columns = [
    'game_id', 'title', 'developer', 'publisher', 'genre', 'release_date',
    'platforms', 'multiplayer_support', 'graphics_quality', 'story_depth',
    'DLC_count', 'max_concurrent_players', 'positive_review_pct',
    'average_review_score', 'review_sentiment_score', 'number_of_reviews'
]

app_list_url = 'http://api.steampowered.com/ISteamApps/GetAppList/v2/'
app_list_response = requests.get(app_list_url)
app_list_data = app_list_response.json()


apps = app_list_data['applist']['apps']
app_ids = [str(app['appid']) for app in apps][:100000]


# set up session
session = requests.Session()
retry = Retry(connect=5, backoff_factor=1, status_forcelist=[502, 503, 504])
adapter = HTTPAdapter(max_retries=retry)
session.mount('http://', adapter)

# store game data
all_games_data = []

for idx, app_id in enumerate(app_ids):
    try:
        url = f'http://store.steampowered.com/api/appdetails?appids={app_id}'
        response = session.get(url, timeout=10)
        response.raise_for_status()
        game_data = response.json()
        
        if game_data.get(app_id) and game_data[app_id]['success']:
            data = game_data[app_id]['data']
            
            filtered_data = {
                'game_id': data.get('steam_appid'),
                'title': data.get('name'),
                'developer': ', '.join(data.get('developers', [])) if data.get('developers') else 'Unknown',
                'publisher': ', '.join(data.get('publishers', [])) if data.get('publishers') else 'Unknown',
                'genre': ', '.join([genre['description'] for genre in data.get('genres', [])]) if data.get('genres') else 'N/A',
                'release_date': data.get('release_date', {}).get('date') if isinstance(data.get('release_date'), dict) else 'TBA',
                'platforms': ', '.join([k for k, v in data.get('platforms', {}).items() if v]) if data.get('platforms') else 'Unknown',
                'multiplayer_support': 'Multi-player' in [category['description'] for category in data.get('categories', [])] if data.get('categories') else False,
                'DLC_count': len(data.get('dlc', [])) if data.get('dlc') else 0,
                'max_concurrent_players': data.get('recommendations', {}).get('total', 0) if data.get('recommendations') else 0,
                'positive_review_pct': data.get('metacritic', {}).get('score', 0) if data.get('metacritic') else 0,
                'average_review_score': data.get('metacritic', {}).get('score', 0) if data.get('metacritic') else 0,
                'review_sentiment_score': data.get('metacritic', {}).get('score', 0) if data.get('metacritic') else 0,
                'number_of_reviews': data.get('recommendations', {}).get('total', 0) if data.get('recommendations') else 0,
                'graphics_quality': 'High' if '4K' in data.get('short_description', '') else 'Standard',
                'story_depth': 'Deep' if 'story' in data.get('short_description', '').lower() else 'Light'
            }

            # get Max Concurrent Players
            max_players_url = f'https://api.steampowered.com/ISteamUserStats/GetNumberOfCurrentPlayers/v1/?appid={app_id}'
            max_players_response = requests.get(max_players_url, timeout=10)

            if max_players_response.status_code == 200:
                max_players_data = max_players_response.json()
                filtered_data['max_concurrent_players'] = max_players_data.get('response', {}).get('player_count', 0)
            else:
                print(f"Failed to fetch max players for App ID {app_id}: Status Code {max_players_response.status_code}")
                filtered_data['max_concurrent_players'] = 0

            all_games_data.append(filtered_data)
        
        print(f"Fetched data for App ID {app_id} ({idx + 1}/{len(app_ids)})")

    except requests.exceptions.RequestException as e:
        print(f"Error fetching data for App ID {app_id}: {e}")
    
    time.sleep(0.5)
        


df = pd.DataFrame(all_games_data, columns=columns)


df.to_csv('games_data.csv', index=False)

print("Data collection complete. Saved to 'games_data.csv'")



```

::: {.callout-tip title="Why random IDs?"}
Since Steam doesn’t provide a direct way to list all public profiles, the script generates random user IDs and checks each one to see if it matches a valid public profile.
:::


## Data Preparation

The Steam library includes more than just released games. It also contains test builds, delisted titles, and placeholder entries. Many of these games/apps had non-standard release dates, such as “Q2 2025” or “Coming soon.” which were removed for the project.

To prepare the data for analysis, entries with missing data were removed.  Playtime values were converted into hours which originally were recorded in minutes.

Here are the columns in the final merged dataset:
```{python}

# Removing rows with any missing values
games_data.dropna(inplace=True)

# Attemptting to parse the dates with possible date formats : 
# Possible formats known from: https://steamcommunity.com/sharedfiles/filedetails/?id=2554483179#:~:text=Date%20part%20order%20can%20be,format%20will%20be%20applied%20immediately.

valid_dates_format1 = pd.to_datetime(games_data['release_date'], format='%d %b, %Y', errors='coerce')
valid_dates_format2 = pd.to_datetime(games_data['release_date'], format='%b %d, %Y', errors='coerce')
valid_dates_format3 = pd.to_datetime(games_data['release_date'], format='%d %b %Y', errors='coerce')

# Identify rows that do not match either of the formats
invalid_dates = games_data[(valid_dates_format1.isna()) & (valid_dates_format2.isna()) & (valid_dates_format3.isna())]

# let's remove those invalid dates
invalid_dates_list = invalid_dates['release_date'].tolist()
games_data = games_data[~games_data['release_date'].isin(invalid_dates_list)]


# Combining all parsed dates
games_data['release_date'] = valid_dates_format1.fillna(valid_dates_format2).fillna(valid_dates_format3)

# Convert dates to 'YYYY-MM-DD' format for consistency only
games_data['release_date'] = games_data['release_date'].dt.strftime('%Y-%m-%d')


# Rename the column from 'appid' to 'game_id'
users_data.rename(columns={'appid': 'game_id'}, inplace=True)

# let's add avg_playtime coloumn - for viz
users_data['avg_playtime'] = users_data['playtime_2weeks'] / 14

# Convert playtime from minutes to hours
users_data['playtime_2weeks'] = users_data['playtime_2weeks'] / 60
users_data['playtime_forever'] = users_data['playtime_forever'] / 60

merged_data = users_data.merge(games_data, on='game_id', how='left')
merged_data.dropna(inplace=True)
for i, col in enumerate(merged_data.columns, start=1):
    print(f"{i}. {col}")
```

# Analysis

###  How much time are people spending on gaming per week?

@fig-distribution below shows the number of hours active users spent gaming per week, based on Steam data. To be considered "active," users needed to have played at least a minute in the past two weeks.

```{python}

#| label: fig-distribution
#| fig-cap: "Weekly playtime distribution among active users, with a 20-hour threshold shown in red."

import plotly.express as px
import plotly.graph_objects as go

# Calculate weekly playtime
active_users = users_data[users_data['playtime_2weeks'] > 0].copy()
active_users['weekly_playtime_hours'] = active_users['playtime_2weeks'] / 2

# Create histogram
fig = px.histogram(
    active_users,
    x='weekly_playtime_hours',
    nbins=30,
    title='Distribution of Weekly Playtime Among Active Users',
    labels={'weekly_playtime_hours': 'Average Weekly Playtime (Hours)'}
)

# Add the threshold line
fig.add_vline(
    x=20,
    line_dash="dash",
    line_color="red",
    annotation_text="Addiction Threshold (20 hours)",
    annotation_position="top right"
)

fig.update_layout(
    xaxis_title='Average Weekly Playtime (Hours)',
    yaxis_title='Number of Active Users',
    bargap=0.1
)

fig.show()

```


The distribution is highly right-skewed, meaning that most users play only a few hours per week, while a smaller group spends a significantly larger amount of time gaming.

A red vertical line is the 20-hour threshold, used thorughout the analysis as the gaming addiction theshold. As the chart shows, the majority of users fall well below this line, clustered between 0-10 hours per week.

::: {.callout-note title="Why 20 Hours?"}

The **20-hour threshold** used in this analysis is based on findings from the *Journal of Behavioral Addictions* [@ajp2021gaming], which reported that addicted individuals played an average of approximately 20 hours per week.

:::

While the histogram gives us a general sense of how often people play, it doesn't tell us much about **how many** users might be at risk. To get a clearer picture, users were categorized based on their weekly playtime.

Let's break this down with a pie chart that groups active users into three categories:

- **Casual Gamers** (under 7 hours per week)  
- **Moderate Gamers** (7 to threshold hours per week)  
- **Potentially Addicted** (above the threshold)


Now, let’s take a look at how these groups compare visually using @fig-piechart:


```{python}

#| label: fig-piechart
#| fig-cap: "Distribution of users across playtime categories: Casual, Moderate, and Potential Addiction."


import plotly.graph_objects as go
import pandas as pd

# Define threshold values and labels
thresholds = list(range(20, 41, 5))
labels = ['Casual Gamer', 'Moderate Gamer', 'Potential Addiction']
colors = ['#46B2DE', '#AEE1AE', '#E57873'] 
frames = []
buttons = []

# Generate pie chart data for each threshold
for threshold in thresholds:
    def categorize(hours):
        if hours < 7:
            return 'Casual Gamer'
        elif hours < threshold:
            return 'Moderate Gamer'
        else:
            return 'Potential Addiction'

    df = active_users.copy()
    df['category'] = df['weekly_playtime_hours'].apply(categorize)
    counts = df['category'].value_counts()
    values = [counts.get(label, 0) for label in labels]

    frames.append(go.Pie(labels=labels, values=values, marker=dict(colors=colors)))

    buttons.append(dict(
        method="update",
        label=f"{threshold} hrs",
        args=[{"values": [values]}],
    ))

# Start with the first threshold's values
init_counts = active_users['weekly_playtime_hours'].apply(lambda h: 'Casual Gamer' if h < 7 else 'Moderate Gamer' if h < 20 else 'Potential Addiction').value_counts()
init_values = [init_counts.get(label, 0) for label in labels]

# Create figure
fig = go.Figure(
    data=[go.Pie(labels=labels, values=init_values, marker=dict(colors=colors))],
    layout=go.Layout(
        title_text="Playtime Category Distribution",
        title_x=0.5,
        height=600,
        margin=dict(t=80, b=100),
        updatemenus=[dict(
            type="dropdown",
            direction="down",
            x=0.01,             # for left position
            xanchor="left",  # anchor to left
            y=0,                # bottom
            yanchor="bottom",
            showactive=True,
            buttons=buttons
        )]
    )
)

fig.show()



```

::: {.callout-note title="Interactive Feature"}
Use the **dropdown menu below the chart** to adjust the *Addiction Threshold* between **20 and 40 hours** per week.  
:::


Based on the 20 hours per week threshold, the results show that a significant majority of users fall well below this level.

**About 75.4%** of active users fall under **Casual Gamers**, meaning they play less than 7 hours per week. This suggests that most people use gaming as a light, recreational activity; something they enjoy in short sessions without making it a major part of their routine.

**Moderate Gamers**, who play between 7 and 20 hours per week, make up **17.9%** of active users. This group shows healthy engagement, likely made up of people who play consistently but still manage to balance gaming with other parts of their lives.

Only **6.6%** of users fall into the **Potential Addiction** category, playing more than 20 hours per week. While this number is not insignificant, it does suggest that gaming addiction is not widespread in this dataset. The overall pattern shows that the majority of gamers engage in moderate or minimal play.

### What drives players to keep playing?
```{python}

#| label: fig-heatmap
#| fig-cap: "Heatmap displaying the correlation between game design features and player playtime metrics."

merged_data = users_data.merge(games_data, on='game_id', how='left')
merged_data.dropna(inplace=True)

# filter only active users (played in last 2 weeks)
merged_data = merged_data[merged_data['playtime_2weeks'] > 0]

# convert 'multiplayer_support' to numeric for correlation
merged_data['multiplayer_support'] = merged_data['multiplayer_support'].astype(int)

# aply log transformation to reduce skewness
merged_data['playtime_forever'] = np.log1p(merged_data['playtime_forever'])
merged_data['playtime_2weeks'] = np.log1p(merged_data['playtime_2weeks'])
merged_data['DLC_count'] = np.log1p(merged_data['DLC_count'])
merged_data['max_concurrent_players'] = np.log1p(merged_data['max_concurrent_players'])
merged_data['average_review_score'] = np.log1p(merged_data['average_review_score'])

# select certain columns for correlation
design_elements = ["DLC_count", "multiplayer_support", "max_concurrent_players", "average_review_score"]
corr_matrix = merged_data[["playtime_forever"] + design_elements].corr().round(2)

# Interactive heatmap with Plotly
fig = px.imshow(
    corr_matrix,
    text_auto=True,
    color_continuous_scale="RdBu_r",
    title="Pearson Correlation Between Game Design Elements and Playtime",
    aspect="auto"
)

fig.update_layout(
    xaxis_title="Game Design Elements",
    yaxis_title="Playtime & Design Elements",
    coloraxis_colorbar=dict(title="Correlation"),
    title_x=0.5,
    margin=dict(t=80, l=60, r=60, b=60)
)

fig.show()

```

Observe the heatmap above (@fig-heatmap) that shows how different game design elements relate to long-term playtime. 


One of the strongest correlations shows up with **maximum concurrent players** *(0.29)*. This probably has a lot to do with the size and popularity of certain games. Titles like *PUBG*, *Rust*, or *ARK: Survival Evolved* are built for large-scale multiplayer, where you enter into a world with lots of other players. The more people there are online, the more unpredictable and exciting each session becomes. No two matches feel the same, and that variety can really keep players coming back.

**Multiplayer support** *(0.22)* also shows a strong positive correlation. The games that let people play together, whether cooperatively or competitively, tend to create a more social and engaging experience. Titles like *Counter-Strike: Global Offensive*, *Dota 2*, or *Valorant* are popular multiplayer games. Not only can you can team up with friends but you can also go head-to-head with strangers. This social side of these games can turn a quick session into a regular habit.

The number of **downloadable content packs or DLCs**  *(0.20)* also appears to play a role. Games like *The Sims 4* or *Cities: Skylines* frequently release DLCs that expand gameplay, add new mechanics, or refresh the visual experience. Players likely find it fun to explore new contents that can be added over time which makes them stick aroung longer.

Interestingly, **average review scores**  *(0.06)* also correlate positively with playtime, but to a lesser degree. While good reviews may attract players initially, they don’t seem to keep players engaged in the same way that gameplay mechanics and social features do. 

###  Are multiplayer games more addictive?

Let's investigate whether there's a relationship between multiplayer support and the likelihood of gaming addiction.

- **Null Hypothesis (H₀):**  
    There is no association between multiplayer support and addiction status. In other words, the proportion of addicted players is the same regardless of whether a game has multiplayer support or not.

- **Alternative Hypothesis (H₁):**  
    There is an association between multiplayer support and addiction status. That is, the proportion of addicted players differs between games with and without multiplayer support.


::: {.callout-note title="Chi-Square Test Result"}
```{python}

#hyopthesis testing
import pandas as pd
from scipy.stats import chi2_contingency

merged_data = users_data.merge(games_data, on='game_id', how='left')
merged_data.dropna(inplace=True)

merged_data = merged_data[merged_data['playtime_2weeks'] > 0]
merged_data['multiplayer_support'] = merged_data['multiplayer_support'].astype(int)


df_filtered = merged_data[merged_data['playtime_2weeks'] > 0].copy()

# Create addicted column: 1 if playtime_2weeks > 20, else 0
df_filtered['addicted'] = (df_filtered['playtime_2weeks'] > 40).astype(int)

# Create contingency table between multiplayer_support and addicted status
contingency_table = pd.crosstab(df_filtered['multiplayer_support'], df_filtered['addicted'])


# Perform the chi-square test
chi2, p, dof, expected = chi2_contingency(contingency_table)
print(f"\nChi-square Statistic: {chi2:.4f}")
print(f"Degrees of Freedom: {dof}")
print(f"P-value: {p}")
```
:::

Since the $p$-value is extremely small ($p < 0.05$), we reject the null hypothesis. This indicates that there is a statistically significant association between multiplayer support and gaming addiction status. In summary, the data provide strong evidence that the proportion of players classified as addicted differs significantly between games with and without multiplayer support.


#### Let’s Go Further: Looking at Other Game Features

To explore this further, let's run t-tests to compare whether certain game features (DLC count, maximum concurrent players, and average review score) differ significantly between addicted and non-addicted players.

::: {.callout-note title="DLC Count"}
- **Null Hypothesis (H₀):**  
  There is no difference in the average number of DLCs between games played by addicted and non-addicted users.

- **Alternative Hypothesis (H₁):**  
  There is a difference in the average number of DLCs between games played by addicted and non-addicted users.
:::

::: {.callout-note title="Maximum Concurrent Players"}
- **Null Hypothesis (H₀):**  
  There is no difference in the average maximum concurrent players between games played by addicted and non-addicted users.

- **Alternative Hypothesis (H₁):**  
  There is a difference in the average maximum concurrent players between games played by addicted and non-addicted users.
:::

::: {.callout-note title="Average Review Score"}
- **Null Hypothesis (H₀):**  
  There is no difference in the average review score between games played by addicted and non-addicted users.

- **Alternative Hypothesis (H₁):**  
  There is a difference in the average review score between games played by addicted and non-addicted users.
:::


::: {.callout-note title="T-Test Results"}
```{python}

import pandas as pd
import numpy as np
from scipy.stats import chi2_contingency
from scipy.stats import ttest_ind


merged_data = users_data.merge(games_data, on='game_id', how='left')
merged_data.dropna(inplace=True)

merged_data = merged_data[merged_data['playtime_2weeks'] > 0]

merged_data['multiplayer_support'] = merged_data['multiplayer_support'].astype(int)


# Assume df_filtered is defined as before with an 'addicted' column
df_filtered = merged_data[merged_data['playtime_2weeks'] > 0].copy()
df_filtered['addicted'] = (df_filtered['playtime_2weeks'] > 40).astype(int)

# Define groups
group_addicted = df_filtered[df_filtered['addicted'] == 1]
group_non_addicted = df_filtered[df_filtered['addicted'] == 0]

# Function to run and print t-test results for a given predictor
def run_ttest(predictor,proper_name):
    t_stat, p_value = ttest_ind(group_addicted[predictor], group_non_addicted[predictor], nan_policy='omit')
    print(f"T-test for {proper_name}:")
    print(f"  t-statistic: {t_stat:.4f}")
    print(f"  p-value: {p_value:.4f}\n")

# Run t-tests for each predictor
run_ttest('DLC_count', 'DLC Count')
run_ttest('max_concurrent_players', 'Maxiumum Concurrent Players')
run_ttest('average_review_score', 'Average Review Score')

```
:::

The results show a clear difference in **DLC (downloadable content packs) count** between the two groups. With a t-statistic of 3.99 and a $p$-value of 0.0001, it’s pretty clear that players who fall into the addicted category are more likely to play games that offer more downloadable content. 

We can see a similar pattern with **maximum concurrent players**. The t-statistic came out to 3.91 with the same $p$-value, which suggests that addicted players tend to be more drawn to games with large, active communities. 

On the flip side, **average review score** didn’t show any real difference between the groups. The t-statistic was -0.92, and the $p$-value was around 0.35, which tells us that reviews don’t really influence whether someone ends up playing a game excessively. A great review might convince someone to try a game, but it doesn’t necessarily mean they’ll keep coming back for dozens of hours.

Altogether, these results back up what we saw earlier in the correlation heatmap. Social features and new downloadable contents seem to play a much bigger role in keeping players in the game than just the game’s rating/review.



### What genres are most engaging?

To understand what types of games addicted and non-addicted users are spending time on, let's break down total playtime by game genre. The charts below compare the top five genres based on total playtime for each group.


```{python}

#| label: fig-genres
#| fig-cap: "Most-played game genres among users with high weekly playtime."

import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

# Merge and clean
merged = users_data.merge(games_data, on="game_id", how="inner")
merged = merged.dropna(subset=["genre", "playtime_2weeks"])

# Split groups
addicted = merged[merged["playtime_2weeks"] > 40].copy()
non_addicted = merged[(merged["playtime_2weeks"] > 0) & (merged["playtime_2weeks"] <= 40)].copy()

# Calculate top 5 genres for each group
def top_genres(df):
    return df.groupby("genre")["playtime_2weeks"].sum().sort_values(ascending=False).head(5).reset_index()

addicted_top = top_genres(addicted)
non_addicted_top = top_genres(non_addicted)

# Create consistent genre-color mapping
all_genres = pd.concat([addicted_top["genre"], non_addicted_top["genre"]]).unique()
colors = px.colors.qualitative.Pastel
genre_colors = {genre: colors[i % len(colors)] for i, genre in enumerate(sorted(all_genres))}

# Addicted plot
fig1 = px.bar(
    addicted_top,
    x="genre",
    y="playtime_2weeks",
    title="Top 5 Genres by Total Playtime (Addicted Users)",
    labels={"playtime_2weeks": "Total Playtime (Hours)", "genre": "Game Genre"},
    color="genre",
    color_discrete_map=genre_colors
)

fig1.update_layout(showlegend=False, xaxis_tickangle=-30)
fig1.show()


```


# 
For addicted users, Strategy games take the lead with the highest total playtime. This suggests that players who spend extended hours gaming may be especially drawn to games that involve planning, decision-making, and long sessions. Following Strategy include RPGs, Action, and hybrid genres like Action-Adventure-RPG, which combine exploration, combat, and story progression in one package.

These types of games often include deep mechanics and flexible systems which encourages prolonged engagement. They tend to be highly replayable by offering varied experiences across different playthroughs.


```{python}

#| label: fig-genres2
#| fig-cap: "Most-played game genres among non-addicted users."


# Non-addicted plot
fig2 = px.bar(
    non_addicted_top,
    x="genre",
    y="playtime_2weeks",
    title="Top 5 Genres by Total Playtime (Non-Addicted Users)",
    labels={"playtime_2weeks": "Total Playtime (Hours)", "genre": "Game Genre"},
    color="genre",
    color_discrete_map=genre_colors
)

fig2.update_layout(showlegend=False, xaxis_tickangle=-30)


fig2.show()
```

# 
Non-addicted players, on the other hand, spend most of their time on Action and Action-Adventure genres. These games tend to offer quick, exciting gameplay in small sessions for more casual play. Titles that fall into these genres often include straightforward objectives, and fast-paced mechanics with visually engaging environments.


While both groups enjoy genres that offer action and adventure, addicted users lean more heavily into genres that demand tactical planning and problem-solving, like Strategy and RPGs. Non-addicted users appear to prefer more fast-paced and accessible experiences. 


### Analyzing Gamers' Sentiments


In order to understand how players feel about the games they play, I conducted a sentiment analysis on user reviews using TextBlob, a natural language processing library that assigns polarity scores to text. Each review was categorized as Positive, Neutral, or Negative based on its sentiment polarity.



```{python}

#| label: fig-sentiments
#| fig-cap: " Distribution of review sentiment across addicted and non-addicted players by sentiment category."

counts_df = pd.read_csv("../results/sentiment_proportions.csv")
sentiment_counts_nonaddicted = dict(zip(counts_df['Sentiment'], counts_df['Proportion_NonAddicted']))
sentiment_counts_addicted = dict(zip(counts_df['Sentiment'], counts_df['Proportion_Addicted']))

# Convert to DataFrame for easier handling
df_sentiments = pd.DataFrame({
    'Sentiment': ['Positive', 'Neutral', 'Negative'],
    'Non-Addicted': [sentiment_counts_nonaddicted.get(sentiment, 0) for sentiment in ['Positive', 'Neutral', 'Negative']],
    'Addicted': [sentiment_counts_addicted.get(sentiment, 0) for sentiment in ['Positive', 'Neutral', 'Negative']]
})

# Create grouped bar chart
fig = go.Figure(data=[
    go.Bar(name='Non-Addicted (Playtime < 20 hrs)', x=df_sentiments['Sentiment'], y=df_sentiments['Non-Addicted']),
    go.Bar(name='Addicted (Playtime > 20 hrs)', x=df_sentiments['Sentiment'], y=df_sentiments['Addicted'])
])

# Customize layout
fig.update_layout(
    title='Sentiment Distribution: Non-Addicted vs Addicted Players',
    xaxis_title='Sentiment Category',
    yaxis_title='Proportion of Reviews',
    barmode='group',
    template='plotly_white',
    legend=dict(x=1, y=1.15, xanchor='left', orientation='v'),
    height=500,
    width=800,
    yaxis_tickformat=".0%"
)

# Show interactive plot
fig.show(config={"displayModeBar": False})



```

@fig-sentiments shows that addicted players leave a slightly higher proportion of positive reviews compared to non-addicted ones (about 63% vs. 59%). Neutral reviews are fairly consistent across both groups, but what's more interesting is that non-addicted users tend to leave more negative reviews. This might suggest that those who spend less time in-game are also more harsh or less emotionally invested, while more engaged players are either more satisfied or more forgiving of a game's flaws.



```{python}

#| label: fig-wordcloud
#| fig-cap: "Word cloud visualization of user review text for Counter-Strike 2, highlighting commonly mentioned terms."

from wordcloud import WordCloud


user_games_combined = users_data.merge(games_data, on='game_id', how='left')
user_games_combined.dropna(inplace=True)
#rename the col for merge
reviews_data.rename(columns={'steamid': 'user_id'}, inplace=True)

df_reviews = user_games_combined.merge(reviews_data, on=['user_id', 'game_id'], how='inner')


# Game IDs and names
top_game_ids = [730, 578080]
top_game_ids_name = ['Counter-Strike 2', 'PUBG: Battlegrounds']

# Filter reviews for these games
df_top_games_reviews = df_reviews[df_reviews["game_id"].isin(top_game_ids)]

# Filter reviews for these games
df_top_games_reviews = df_reviews[df_reviews["game_id"].isin(top_game_ids)]

ind = 0
game_id = top_game_ids[ind]
# Generate and display word clouds for first game

game_reviews = df_top_games_reviews[df_top_games_reviews["game_id"] == game_id]["review"].dropna()
text = " ".join(game_reviews)

# Generate word cloud
wordcloud = WordCloud(width=800, height=400, background_color="white", colormap="viridis").generate(text)

# Plot word cloud
plt.figure(figsize=(10, 5))
plt.imshow(wordcloud, interpolation="bilinear")
plt.axis("off")
plt.title(f"Word Cloud for Game ID: {top_game_ids_name[ind]}")
plt.show()
ind += 1


```


Let’s take a look at @fig-wordcloud. It  highlights the most frequently used words in reviews for Counter-Strike 2, the most popular game title in the dataset. A few strong themes quickly stand out. Words like “cheaters,” “Valve,” “time,” and “play” dominate the discussion, pointing to both the game's popularity and common frustrations. While some players express positive feelings with words like “thank,” “love,” and “fun,” others vent through terms like “broken,” “trash,” and “VAC.” This mix shows how competitive games can be both fun and frustrating, which can lead players to keep coming back.



```{python}

#| label: fig-wordcloud2
#| fig-cap: "Word cloud visualization of user review text for PUBG: Battlegrounds, highlighting commonly mentioned terms."

from wordcloud import WordCloud


user_games_combined = users_data.merge(games_data, on='game_id', how='left')
user_games_combined.dropna(inplace=True)
#rename the col for merge
reviews_data.rename(columns={'steamid': 'user_id'}, inplace=True)

df_reviews = user_games_combined.merge(reviews_data, on=['user_id', 'game_id'], how='inner')


# Game IDs and names
top_game_ids = [730, 578080]
top_game_ids_name = ['Counter-Strike 2', 'PUBG: Battlegrounds']

# Filter reviews for these games
df_top_games_reviews = df_reviews[df_reviews["game_id"].isin(top_game_ids)]

# Filter reviews for these games
df_top_games_reviews = df_reviews[df_reviews["game_id"].isin(top_game_ids)]

ind = 1
game_id = top_game_ids[ind]
# Generate and display word clouds for second game

game_reviews = df_top_games_reviews[df_top_games_reviews["game_id"] == game_id]["review"].dropna()
text = " ".join(game_reviews)

# Generate word cloud
wordcloud = WordCloud(width=800, height=400, background_color="white", colormap="viridis").generate(text)

# Plot word cloud
plt.figure(figsize=(10, 5))
plt.imshow(wordcloud, interpolation="bilinear")
plt.axis("off")
plt.title(f"Word Cloud for Game ID: {top_game_ids_name[ind]}")
plt.show()



```


Similarly, @fig-wordcloud2 breaks down player sentiments for PUBG: Battlegrounds, another popular game title. The emphasis on words like “fun,” “good,” “free,” and “recommend” suggest a generally positive experience. However, negative terms such as “cheaters,” “broken,” “stop,” and “unplayable” also appear frequently. These reflect common complaints about technical issues including lag, server instability, and internet provider (ISP) problems. All of this can seriously impact the multiplayer experience. And this shows even widely loved games aren’t immune to frustration.

Together, these insights suggest that sentiment and addiction aren’t always negatively correlated—players can be highly engaged and still critical. But the intensity and frequency of feedback from addicted players may signal stronger emotional investment in the game experience.


# Predicting Gaming Addiction

After exploring trends in playtime, game design, and genre preferences, the next  step is to see if we could predict gaming addiction using machine learning.

To do this, I trained and tested several classification models using both numerical features (like total number of games owned, average review score, and number of reviews) and categorical features (such as genre, platforms, and whether a game supports multiplayer). Together, these features offer a broad snapshot of both the player's behavior and the characteristics of the games they engage with.

The goal here is to build a model that can distinguish between users who are likely to be addicted and those who are not, based on the types of games they play and how they interact with them.

Below is a comparison of the top-performing models. 




```{python}

#| label: tbl-metricsdata
#| tbl-cap: "Precision, recall, and F1-score for models across user classes"

df_scores = pd.read_csv("../results/classifier_metrics.csv")

df_scores = df_scores[['Model', 'Class', 'precision', 'recall', 'f1-score']]

df_scores[['precision', 'recall', 'f1-score']] = df_scores[['precision', 'recall', 'f1-score']].round(3)


# capitalize the columns header for displaying
df_scores.columns = [col.capitalize() for col in df_scores.columns]

df_scores

```


::: {.callout-note}

Using the dropdown, you can check out the chart below to view how each model performed.

:::

```{python}

#| label: fig-metrics
#| fig-cap: "Precision, recall, and F1-score for differnt models across both addicted and non-addicted user classes."


import plotly.graph_objects as go

# Define model names and metrics
models = ["Logistic Regression", "XGBoost", "KNN", "Bagging", "Decision Tree", "SVM"]


df = pd.read_csv("../results/classifier_metrics.csv")
# let's get the scores from the result
scores = {}

# Iterate over rows
for _, row in df.iterrows():
    model = row['Model']
    cls = row['Class']
    metrics = [round(row['precision'], 4), round(row['recall'], 4), round(row['f1-score'], 4)]
    
    if model not in scores:
        scores[model] = {}
    scores[model][cls] = metrics

# Initialize the first model (XGBoost) as default
initial_model = "XGBoost"
metrics = ["Precision", "Recall", "F1-Score"]
fig = go.Figure()

fig.add_trace(go.Bar(
    name="Not Addicted",
    x=metrics,
    y=scores[initial_model]["Not Addicted"],
    marker_color="#2a9d8f"
))
fig.add_trace(go.Bar(
    name="Addicted",
    x=metrics,
    y=scores[initial_model]["Addicted"],
    marker_color="#e76f51"
))

# Dropdown buttons
buttons = []
for model in models:
    buttons.append(dict(
        label=model,
        method="update",
        args=[{"y": [scores[model]["Not Addicted"], scores[model]["Addicted"]],
               "x": [metrics, metrics]},
              {"title": f"Classification Metrics for {model}"}]
    ))

# Layout
fig.update_layout(
    updatemenus=[dict(
        buttons=buttons,
        direction="down",
        showactive=True,
        x=0.99,
        xanchor="right",
        y=1.15,
        yanchor="top"
    )],
    barmode="group",
    title=f"Classification Metrics for {initial_model}",
    yaxis_title="Score",
    yaxis=dict(range=[0.6, 0.9]),
    height=500
)

fig.show(config={"displayModeBar": False})

```

#
Based on the comparison, XGBoost is the top-performing model, with the highest F1-score for the Addicted class (0.8289) and strong, balanced metrics across both classes. Models like Bagging and Decision Tree also performed well, with solid precision and recall, while Logistic Regression was a good starting point, but its recall was a bit lower. On the other hand, KNN and SVM struggled, especially in identifying "Not Addicted" users accurately. This suggests that more advanced ensemble-based models are better suited for capturing the patterns behind gaming addiction. 

Now that we know XGBoost performs best, let's take a closer look at which features had the most influence in its predictions:

```{python}


#| label: fig-featureimportance
#| fig-cap: "Top 10 features ranked by importance in the XGBoost model used to predict gaming addiction."


import pandas as pd
import plotly.express as px


feature_data = pd.read_csv("../results/xgfeatures.csv")

# Create interactive horizontal bar chart
fig = px.bar(
    feature_data.sort_values("Importance"),
    x="Importance",
    y="Feature",
    orientation="h",
    title="Top 10 Most Important Features in XGBoost Model",
    labels={"Importance": "Feature Importance", "Feature": "Feature"},
    color="Importance"
)

fig.update_traces(marker_color="#3b82f6")

fig.update_layout(height=500, yaxis_title="", coloraxis_showscale=False)

# Hide Plotly mode bar
fig.show(config={"displayModeBar": False})


```


#
 Interestingly, the number of games owned(game_count) came out as the most influential feature, which makes sense since players who own a large library may be more engaged overall. Specific developers and publishers also played a role, with games from Aurora Studio, Valve, and Team17 showing up frequently among addicted users. Certain genres stood out too: titles labeled as Casual, Action, or hybrid genres like Action-Adventure-Indie carried significant weight in the model. The number of user reviews(number_of_reviews) and maximum concurrent players(max_concurrent_players) were also important, suggesting that both popularity and social engagement may contribute to prolonged playtime. Overall, these features paint a picture of gaming addiction as a mix of player behavior, game design, and community-driven influence.



# Future Work

There are lots of exciting possibilities and ideas for building on this work. One idea is to apply more advanced neural networks, like RNNs or transformer models, to capture even deeper patterns in player behavior and push prediction accuracy even higher. Another is to use time series analysis to track how gaming habits change over time which could give a better picture of when and how addiction risks start to form. This approach would require downloading and tracking player data from the API over several months. Lastly, it would also be interesting to create dynamic, real-time dashboards to monitor gaming trends as they happen, making the data easier to explore. 